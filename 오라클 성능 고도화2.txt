인덱스 원리와 활용 
 1. 1-3절 : 인덱스 기본 구조 및 다양한 스캔 방식
   ** 범위스캔  
     -- 전체 데이터를 조회하는 것이 아닌 부분 범위의 데이터를 스캔하는 것?
 2. 4-6절 : 인덱스를 경유한 테이블 Random 액세스 부하 해소 원리
  ** 4절    : 대용량 데이터를 처리할때 테이블 Random 액세스가 부하 요인으로 작용하는 원인 
  ** 5-6절 : 이를 해소하기위한 튜닝 방안을 소개 
 3. 7절    : 인덱스를 스캔할 때 비효율이 발생하는 원인을 설명, 
              이를 해소하기 위한 인덱스 구성 원리 및 SQL 튜닝 방안을 소개 
 4. 8절    : 1장에서 가장 중요하다고 할 수 있는 인덱스 설계 방안을 소개 

  3절 다양한 인덱스 스캔 방식
    ... 
    ** Index Fast Full Scan 
      -- Multblock Read 방식을 사용함으로 디스크로부터 대량의 인덱스 블록을 읽어야 하는 상황에서 큰효과를 발휘
      -- 인덱스 리프 노드가 갖는 연결 리스트 구조를 이용하지는 않기때문에, 결과집합이 인덱스 키 순서대로 정렬되         지는 않음 
      -- 쿼리에서 사용되는 모든 컬럼이 인덱스 컬럼에 포함돼 있을 때만 사용 가능함 
      -- 인덱스가 파티션 돼 있지 않더라도 병렬쿼리가 가능함(병렬 쿼리시 Direct Path Read 방식 사용)
      -- 검색된 결과 건수가 많아지면 테이블에 대한 Random Access가 많아져 이방식이 불리해질 수 있음
         (단, 부분 범위 처리가 가능한 애플리케이션 환경이라면 손해 볼것이 없음)

    ** Index Range Scan Descending
      -- 인덱스를 뒤에서부터 앞쪽으로 스캔하면서 내림차순으로 정렬된 결과집합을 가짐
      -- max 값을 구하고자 할때도 인덱스 뒤에서 한건만 읽고 멈추는 실행계획이 자동 수립됨

    ** And-Equal, Index Combine, Index Join
      -- And-Equal 
        * 인덱스가 단일컬럼의 Non-Unique 인덱스여야하고, 인덱스 컬럼에 대한 조건절이 '=' 이어야 함
        * '=' 조건을 전제로 하므로, 인덱스 필터링을 거친 양쪽 집합은 rowid 순으로 정렬된 상태 
        * 데이터 분포도가 좋지 않아 단독으로는 테이블 Random 액세스를 많이 발생시키는 단일컬럼 
          인덱스를 2개 이상(최대 5개) 결합하여 테이블 액세스량을 줄이는 것이 목적

      -- Index Combine
        * 데이터 분포도가 좋지 않은 2개 이상의 인덱스를 결합해 Random 액세스량을 줄이는 것이 목적
        * 조건절이 '=' 이어야 할 필요가 없고, Non-Unique 인덱스일 필요도 없음 게다가, 비트맵 인덱스를 이용하므로
          조건절을 OR로 결합된 경우에도 유용하다.
        * 아 기능은 _b_tree_bitmap_plan = true 일 경우 사용가능, 9i부터는 default가 true

      -- Index Join
        * 한 테이블에 속한 여러 인덱스를 이용해 테이블 액세스 없이 결과집합을 만들 때 사용하는 인덱스 스캔 방식
        * Index Join은 Hash Join 매커니즘을 그대로 사용함
        * Index Join은 쿼리에 사용된 컬럼들이 인덱스에 모두 포함될 때만 작동
          (사용되는 컬럼 중 어느 한쪽에만 포함되기만 하면됨)

  4절 테이블 Random 액세스 부하 원인
    ** 인덱스 ROWID에 의한 테이블 액세스
      -- 쿼리에서 참조되는 컬럼이 인덱스에 모두 포함되지않는다면 인덱스 스캔 이후 테이블 Random Access 발생
         실행계획에서 Table Access By Index ROWID가 Random Access에 해당함
        * ROWID 
          - 인덱스에 저장된 rowid는 물리적 주소 정보라고도 불림
            (오브젝트 번호, 데이터파일 번호, 블록 번호 같은 물리적 요소들로 구성됨)
          - 보는 시각에 따라서는 논리적 주소 정보라고 표현하기도 함
        * 메인 메모리 DB와의 비교 
          - 오우.... 이건 나중에 한번 더 정리합시다 ㅋㅋㅋ 
        * rowid는 우편주소에 해당
          - 메인 메모리 DB는 전화번호에 해당해 곧바로 연결이 되지만 
            rowid는 우편 주소에 해당해 우체부 아저씨가 일일이 찾아다니는 구조로 이루어져 있음
           (결론적으로 rowid가 더 느림)
        * 인덱스 rowid에 의한 테이블 액세스 구조
          - 인덱스 rowid는 테이블 레코드와 물리적으로 연결돼 있지 않기 때문에 인덱스를 통한 액세스 보다 
            고비용 구조임
          - 설령 모든 데이터가 메모리에 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA를 해싱하고 
	래치 획득 과정을 반복해야 함으로, 동시 액세스가 심할 때는 래치와 버퍼 Lock에 대한 경합도 발생

    ** 인덱스 클러스터링 팩터 
      -- 군집성 계수(= 데이터가 모여 있는 정도)
        * 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
      -- 클러스터링 팩터 조회 
        * 보면서 한번더 정리
      -- 클러스터링 팩터와 물리적 I/O
        * "인덱스 CF가 좋다"고 하면 인덱스 정렬 순서와 테이블 정렬 순서가 서로 비슷한다는 것을 말함
           테이블 정렬 순서가 좋다는 의미는 궁극적으로 물리적인 디스크 I/O 횟수를 감소시키는 효과가 있음을 말함
      -- 클러스터링 팩터와 논리적 I/O
        * 인덱스 CF는 단적으로 말해, 인덱스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적
          블록 개수를 의미