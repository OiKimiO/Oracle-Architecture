인덱스 원리와 활용 
 1. 1-3절 : 인덱스 기본 구조 및 다양한 스캔 방식
   ** 범위스캔  
     -- 전체 데이터를 조회하는 것이 아닌 부분 범위의 데이터를 스캔하는 것?
 2. 4-6절 : 인덱스를 경유한 테이블 Random 액세스 부하 해소 원리
  ** 4절    : 대용량 데이터를 처리할때 테이블 Random 액세스가 부하 요인으로 작용하는 원인 
  ** 5-6절 : 이를 해소하기위한 튜닝 방안을 소개 
 3. 7절    : 인덱스를 스캔할 때 비효율이 발생하는 원인을 설명, 
              이를 해소하기 위한 인덱스 구성 원리 및 SQL 튜닝 방안을 소개 
 4. 8절    : 1장에서 가장 중요하다고 할 수 있는 인덱스 설계 방안을 소개 

  3절 다양한 인덱스 스캔 방식
    ... 
    ** Index Fast Full Scan 
      -- Multblock Read 방식을 사용함으로 디스크로부터 대량의 인덱스 블록을 읽어야 하는 상황에서 큰효과를 발휘
      -- 인덱스 리프 노드가 갖는 연결 리스트 구조를 이용하지는 않기때문에, 결과집합이 인덱스 키 순서대로 정렬되         지는 않음 
      -- 쿼리에서 사용되는 모든 컬럼이 인덱스 컬럼에 포함돼 있을 때만 사용 가능함 
      -- 인덱스가 파티션 돼 있지 않더라도 병렬쿼리가 가능함(병렬 쿼리시 Direct Path Read 방식 사용)
      -- 검색된 결과 건수가 많아지면 테이블에 대한 Random Access가 많아져 이방식이 불리해질 수 있음
         (단, 부분 범위 처리가 가능한 애플리케이션 환경이라면 손해 볼것이 없음)

    ** Index Range Scan Descending
      -- 인덱스를 뒤에서부터 앞쪽으로 스캔하면서 내림차순으로 정렬된 결과집합을 가짐
      -- max 값을 구하고자 할때도 인덱스 뒤에서 한건만 읽고 멈추는 실행계획이 자동 수립됨

    ** And-Equal, Index Combine, Index Join
      -- And-Equal 
        * 인덱스가 단일컬럼의 Non-Unique 인덱스여야하고, 인덱스 컬럼에 대한 조건절이 '=' 이어야 함
        * '=' 조건을 전제로 하므로, 인덱스 필터링을 거친 양쪽 집합은 rowid 순으로 정렬된 상태 
        * 데이터 분포도가 좋지 않아 단독으로는 테이블 Random 액세스를 많이 발생시키는 단일컬럼 
          인덱스를 2개 이상(최대 5개) 결합하여 테이블 액세스량을 줄이는 것이 목적

      -- Index Combine
        * 데이터 분포도가 좋지 않은 2개 이상의 인덱스를 결합해 Random 액세스량을 줄이는 것이 목적
        * 조건절이 '=' 이어야 할 필요가 없고, Non-Unique 인덱스일 필요도 없음 게다가, 비트맵 인덱스를 이용하므로
          조건절을 OR로 결합된 경우에도 유용하다.
        * 아 기능은 _b_tree_bitmap_plan = true 일 경우 사용가능, 9i부터는 default가 true

      -- Index Join
        * 한 테이블에 속한 여러 인덱스를 이용해 테이블 액세스 없이 결과집합을 만들 때 사용하는 인덱스 스캔 방식
        * Index Join은 Hash Join 매커니즘을 그대로 사용함
        * Index Join은 쿼리에 사용된 컬럼들이 인덱스에 모두 포함될 때만 작동
          (사용되는 컬럼 중 어느 한쪽에만 포함되기만 하면됨)

  4절 테이블 Random 액세스 부하 원인
    ** 인덱스 ROWID에 의한 테이블 액세스
      -- 쿼리에서 참조되는 컬럼이 인덱스에 모두 포함되지 않는다면 인덱스 스캔 이후 테이블 Random Access 발생
         실행계획에서 Table Access By Index ROWID가 Random Access에 해당함
        * ROWID 
          - 인덱스에 저장된 rowid는 물리적 주소 정보라고도 불림
            (오브젝트 번호, 데이터파일 번호, 블록 번호 같은 물리적 요소들로 구성됨)
          - 보는 시각에 따라서는 논리적 주소 정보라고 표현하기도 함
        * 메인 메모리 DB와의 비교 
          - 오우.... 이건 나중에 한번 더 정리합시다 ㅋㅋㅋ 
        * rowid는 우편주소에 해당
          - 메인 메모리 DB는 전화번호에 해당해 곧바로 연결이 되지만 
            rowid는 우편 주소에 해당해 우체부 아저씨가 일일이 찾아다니는 구조로 이루어져 있음
           (결론적으로 rowid가 더 느림)
        * 인덱스 rowid에 의한 테이블 액세스 구조
          - 인덱스 rowid는 테이블 레코드와 물리적으로 연결돼 있지 않기 때문에 인덱스를 통한 액세스 보다 
            고비용 구조임
          - 설령 모든 데이터가 메모리에 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA를 해싱하고 
	래치 획득 과정을 반복해야 함으로, 동시 액세스가 심할 때는 래치와 버퍼 Lock에 대한 경합도 발생

    ** 인덱스 클러스터링 팩터(Index Clustering Factor)
      -- 군집성 계수(= 데이터가 모여 있는 정도)
        * 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
      -- 클러스터링 팩터 조회 
        * 보면서 한번더 정리
      -- 클러스터링 팩터와 물리적 I/O
        * "인덱스 CF가 좋다"고 하면 인덱스 정렬 순서와 테이블 정렬 순서가 서로 비슷한다는 것을 말함
           테이블 정렬 순서가 좋다는 의미는 궁극적으로 물리적인 디스크 I/O 횟수를 감소시키는 효과가 있음을 말함
      -- 클러스터링 팩터와 논리적 I/O
        * 인덱스 CF는 단적으로 말해, 인덱스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적
          블록 개수를 의미
        * CF가 좋을 때는 인덱스 통계에 나타나는 clustering_factor가 전체 테이블 블록 개수와 일치
          가장 않좋을 때는 총 레코드 개수와 일치함
      -- 버퍼 Pinning에 의한 논리적 I/O 감소 원리 
        * CF(Clustering Factor)가 좋으면 인덱스의 해시 체인 래치 획득을 최소화하며 테이블을 액세스 할 수 있어                  Random 블록 I/O가 감소해 테이블 블록 수만큼만 접근할 수 있음, 하지만 최악의 경우 테이블 레코드 
          갯수만큼의 Random 블록 I/O가 발생 할 수 있음
      -- 인덱스 손익분기점
        * Index Range Scan이 Table Full Scan 보다 더 느려지는 지점을 '손익 분기점'이라고 부른다.
        * Index Range Scan이 Full Table Scan보다 더 느려지게 만든는 가장 핵심적인 두가지 요인 
          - 인덱스 rowid에 의한 테이블 액세스는 Random Access인 반면, Full Table Scan은 Sequential Access 
	방식으로 이루어짐
          - 디스크 I/O시 , 인덱스 rowid에 의한 테이블 액세스는 Single Block Read방식을 사용하는 반면, 
 	Full Table Scan은 Multiblock Read 방식을 사용한다.
        * 손익 분기점 계산 방법 
          - 노트를 참고하자!
          - 손익 분기점이 시작되는 부분에서 읽은 RECORD의 갯수 / 총 레코드 수 * 100
          - 높으면 높을 수록 인덱스의 rowid와 테이블 블록의 레코드 순서가 일치함을 말함
        * 손익 분기점 개념이 도입된 이유는 테이블 스캔이 항상 나쁜것은 아니며, 인덱스 스캔도 항상 나쁜것은 
           아니라는 것을 보여주기 위해 사용함
        * 이러한 인덱스가 갖는 한계를 잘 극복하기 위해서 부분범위처리 원리를 적극 활용해야 함
        * 손익분기점을 극복하기 위한 기능들 
          - IOT(Index-Organized Table)
	테이블을 인덱스 구조로 생성, 테이블 자체가 인덱스 구조임으로 항상 정렬된 상태를 유지한다.
	그리고 인덱스 리프 블록이 데이터 블록이어서 인덱스를 수직 탐색한 다음에 테이블 레코드를 읽기 위한 
	Random Access가 발생하지 않는다. 
          - 클러스터 테이블(Clustered Table)
	키값이 같은 레코드는 같은 블록에 모이도록 저장하기 때문에 클러스터 테이블의 경우 테이블에 접근하기
	위한 Random Access가 키값 별로 발생한다. 클러스터에 도달해서는 Sequential 방식으로 스캔하기 때문에 
	넓은 범위를 읽더라도 비효율이 없다.
          - 파티셔닝 
	대용량 데이터에서 자주 사용되는 컬럼을 기준으로 테이블을 파티셔닝하는 것을 말함

  5절 테이블 Random Access 최소화 튜닝 방안과 사례
    ** 인덱스 컬럼 추가 
      -- 쿼리 조회시 조건문에 인덱스 컬럼 이외의 컬럼을 사용하게 되면 테이블에 접근시 Random하게 접근하는 
         비율이 증가하게되고, 이로인해 CF(Clustering Factor)가 매우 나빠진다. 
         따라서 인덱스 컬럼이외의 컬럼을 인덱스에 포함시켜 Random Access 비율을 줄인다. 

    ** PK 인덱스에 컬럼 추가 
      -- 추후에 NL 조인에 대한 개념을 익힌 뒤 다시 작성

    ** 컬럼 추가에 따른 클러스터링 팩터 변화 (추후 다시 확인)
      -- 인덱스 내에서 같은 키값이 같은 레코드는 rowid순으로 정렬된다. 그런데 변별력이 좋은 컬럼을 
         인덱스에 추가하게 되면 변별력이 좋은 컬럼순으로 정렬됨으로 클러스터링 팩터를 나쁘게 만들수 있다.

    ** 컬럼 추가에 따른 클러스터링 팩터 변화 (추후 다시 확인)

    ** 인덱스만 추가 (추후 다시 확인)

    ** 버퍼 Pinning 효과 활용 (추후 다시 확인)

    ** 수동으로 클러스터링 팩터 높이기 (추후 다시 확인)

  6절 IOT, 클러스터 테이블 활용
    ** IOT란?
      -- 테이블을 Index 구조로 생성하는 것, 인덱스 리프 블록이 곧 데이터 블록이라고 생각하면 됨
      -- 보통 테이블은 heap 구조로 저장돼 데이터 삽입이 Random하게 들어가지만, IOT의 경우 
          Index 구조 테이블임으로 정렬 상태를 유지하여 데이터를 입력한다.
      -- IOT의 장점과 단점 
         * 같은 값을 가진 레코드들이 100% 정렬된 상태로 모이기 때문에 Sequential 방식으로 데이터를 Access 
           이때문에 넓은 범위를 액세스할 때 유리함 
         * IOT가 PK 이외에 많은 컬럼을 갖는 다면 리프블록에 저장해야할 데이터량이 늘어나 인덱스 분할이 늘어남
           그래서 인덱스 효율이 안좋아짐
      -- IOT는 언제 사용할 것인가?
         * 크기가 작고 NL 조인으로 반복 룩업(Lookup)하는 테이블 
         * 컬럼이 적고 로우 수가 많은 테이블 
         * 넓은 범위를 주로 검색하는 테이블
         * 데이터 입력과 조회 패턴이 서로 다른 테이블