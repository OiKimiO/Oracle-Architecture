1. REDO vs UNDO
 -- REDO의 특징 
   * 데이터의 변경 사항들을 모두 기록한다.
   * 모든 데이터가 저장되어 있음으로 data recovery시 사용된다.

 -- UNDO의 특징 
   * 데이터의 변경이 가해지면 이전에 대한 정보를 저장해 필요시 이전 데이터를 가져온다.
   * DML 오퍼레이션별 UNDO 레코드에 기록되는 내용
     - Insert   : 추가된 레코드의 rowid
     - Update : 변경되는 컬럼에 대한 before image 
     - Delete  : 지워지는 로우의 모든 컬럼에 대한 before image
     - undo_retention : 트랜잭션이 완료되었어도 지정한 시간 동안은 "가급적" Undo 데이터를 재사용하지 말라고 
 		    오라클에 힌트를 주는 것

2. current read vs consistent read 
 -- consistent read : UNDO에 저장된 변경전 데이터를 통하여 읽기 읽관성을 유지한다.
 -- current read     : DML 조작을 통하여 최종으로 변경된 데이터를 기준으로 읽는다.
   * 블록 SCN > 쿼리 SCN
     - 블록 SCN이 더 큼으로 consistent read시 current 블록을 CR 블록으로 생성하여 문장의 일관성을 유지한다. 
     - 블록 SCN은 하나가 아니라 여러개가 존재함으로 여러 CR 블록이 존재할 수 있다. 

2. LGWR, DBWR
 * REDO LOG BUFFER의 내용을 REDO LOG FILE에 기록함 
   -- 데이터 변경사항이 기록되는 REDO의 데이터 처리방식의 이해 필요

3. 클린 아웃
 * 데이터 처리 방식의 이해
 * Delayed Block Clean Out vs Fast Block Clean Out
   -- 클린아웃 후 Lock Byte가 풀리는 시점은?
   -- DUMP 참조시 확인할 내용 
 * 클린 아웃 실패 
   -- 최저 커밋 SCN이 쿼리 SCN보다 높을 떄 snap shot too old 발생
 
4. snap shot too old 
 * 언제 발생하는지 ? 다른 트랙잭션이 사용하는 UNDO 세그먼트를 현재 처리중인 
		 다른 트랜잭션이 사용해야할 경우 
   		 지나친 commit은 지양해야한다.
 * 에러가 발생을 예방하는 방법?
 
5. Nested Loop Join 
 * 개념

6. transaction
 * 고립화 수준 
   -- 총 4단계 정리 
 * 고립화 수준에 따른 문제점
   -- 고립화 수준별 문제점 정리

7.pseudo 컬럼?

8. 비트맵 인덱스 엔트리?

9. 데이터베이스 성능 고도화 정석 해법 
 (1) 문제해결 : 모니터링 자료수집 -> 분석 진단 -> 튜닝 -> 평가 
 (2) 데이터 베이스 성능 튜닝 3대 핵심요소 
   (2-1) 라이브러리 캐시 최적화
   (2-2) 데이터베이스 Call 최소화
   (2-3) I/O 효율화 및 버퍼캐시 최적화

10. 라이브러리 캐시 최적화 
    ** 라이브러리 캐시 최적화시 고려사항
      -- 바인드 변수 중요성, 바인드 변수 사용시 부작용
      -- 과도한 parse call이 발생해도, cursor를 session에 캐싱 혹은 애플리케이션에 캐싱 하여 parse call을 줄이기
      -- daynamic SQL vs Static SQL
      -- Library cache에 부하를 주지않는 선에서 dynamic SQL을 사용하는 방법

    ** 라이브러리 캐시 
      -- 파싱 과정을 거친 SQL 커서를 재사용할 수 있도록 캐싱해 두는 메모리 공간
      -- 데이터베이스 오브젝트(테이블, 인덱스)에 대한 정보를 관리    

    ** 라이브러리 캐시 최적화를 위해 개발자가 신경 써야할 것
      -- 커서를 공유할 수 있는 형태로 SQL 작성
         * 공유커서 : 라이브러리 캐시의 파싱을 거친 SQL 커서를 말함
         * 공유커서가 무효화 될 수 있는 경우 
           - 테이블 컬럼 추가/삭제, 인덱스 변경, 오브젝트 통계 수집하는 DDL 실행
      -- 세션 커서 캐싱 기능 이용해 라이브러리 캐시에서 SQL을 찾는 비용을 줄이기
      -- 애플리케이션 커서 캐싱을 이용해 parse call을 줄이기 

    ** 라이브러리 캐시 부하 원인 
      -- 하드 파싱/ 소프트 파싱이 자주 일어날 때
      -- SQL 수행 도중 DDL문을 날릴 때(library cache lock과 library cache pin 대기 이벤트 발생)
         * library cache lock : 라이브러리 캐시 객체(LCO)구조를 보호, library cache pin : LCO의 정보를 읽거나 수정 
      -- Child Cursor를 공유하지 못할 때 
         * 실행환경(옵티마이저 param, 스키마..등)이 변경되었을 때 
      -- Parent Cursor를 공유하지 못할 때
         * 대/소문자 다름, 테이블에 스키마 붙음, 띄어쓰기, 주석처리, 옵티마이저 힌트 사용, 조건절 비교값(하드코딩)

     ** 바인드 변수의 중요성 
      -- 바인드 변수를 잘 활용하면 하드 파싱의 비율이 줄어들어 시스템 부하가 많이 줄어든다. 
      -- 바인드 변수를 사용하면 최초 수행할 때 최적화를 거친 실행계획을 캐시에 적재하고, 실행시점에는 그것을 
          그대로 가져와 값을 다르게 바인딩하면서 반복 재사용함

     ** 바인드 변수의 부작용과 해법 
      -- 바인딩 시점이 (최적화 시점보다 나중인)실행지점이기 때문에, 
          SQL 최적화 하는 시점에 조건절 컬럼의 데이터 분포도를 활용하지 못하는 문제를 가짐 
      -- 데이터 분포도를 활용하지 못함으로 평균 분포를 통해 실행계획을 세우는데, 평균 분포에 근거한 실행계획이
          최악일 수 있음(정확한 수치를 통한 계획이 아니기 때문에 그럼)
      -- 부작용의 해법 (한번 다시 봐야 할듯.. ㅠㅜ)
        * 바인드 변수 peeking 
          - 문제의 소지가 있어 잘 안씀 ㅋㅋ 개념이 어렵네요 ㅋㅋㅋ 
        * 적응적 커서 공유 
          - 이해가 잘 안가는데;; 
        * 입력값에 따라 SQL 분리
          - union all, IF 로 계획도가 비슷한 쿼리끼리 묶어 만들기
          - 하지만 union all은 OLTP 시스템에서 parse 과정에서의 부하가 있을 수 있음 그래서 상황에 따라 쓸 것
        * 예외적으로 Literal 상수값 사용 
          - 예외적으로 조건 값이 얼마 되지 않을 경우 상수값을 넣는 것도 부하를 줄일 수 있음
          - 하지만 대부분의 상황에서는 바인드 변수를 사용하는 것이 좋음!

      ** 세션 커서 캐싱 .. 다시 봐야할듯 ㅋㅋㅋ
      ** 어플리케이션 커서 캐싱 부터 다시 시작