1. REDO vs UNDO
 -- REDO의 특징 
   * 데이터의 변경 사항들을 모두 기록한다.
   * 모든 데이터가 저장되어 있음으로 data recovery시 사용된다.

 -- UNDO의 특징 
   * 데이터의 변경이 가해지면 이전에 대한 정보를 저장해 필요시 이전 데이터를 가져온다.
   * DML 오퍼레이션별 UNDO 레코드에 기록되는 내용
     - Insert   : 추가된 레코드의 rowid
     - Update : 변경되는 컬럼에 대한 before image 
     - Delete  : 지워지는 로우의 모든 컬럼에 대한 before image
     - undo_retention : 트랜잭션이 완료되었어도 지정한 시간 동안은 "가급적" Undo 데이터를 재사용하지 말라고 
 		    오라클에 힌트를 주는 것

2. current read vs consistent read 
 -- consistent read : UNDO에 저장된 변경전 데이터를 통하여 읽기 읽관성을 유지한다.
 -- current read     : DML 조작을 통하여 최종으로 변경된 데이터를 기준으로 읽는다.
   * 블록 SCN > 쿼리 SCN
     - 블록 SCN이 더 큼으로 consistent read시 current 블록을 CR 블록으로 생성하여 문장의 일관성을 유지한다. 
     - 블록 SCN은 하나가 아니라 여러개가 존재함으로 여러 CR 블록이 존재할 수 있다. 

2. LGWR, DBWR
 * REDO LOG BUFFER의 내용을 REDO LOG FILE에 기록함 
   -- 데이터 변경사항이 기록되는 REDO의 데이터 처리방식의 이해 필요

3. 클린 아웃
 * 데이터 처리 방식의 이해
 * Delayed Block Clean Out vs Fast Block Clean Out
   -- 클린아웃 후 Lock Byte가 풀리는 시점은?
   -- DUMP 참조시 확인할 내용 
 * 클린 아웃 실패 
   -- 최저 커밋 SCN이 쿼리 SCN보다 높을 떄 snap shot too old 발생
 
4. snap shot too old 
 * 언제 발생하는지 ? 다른 트랙잭션이 사용하는 UNDO 세그먼트를 현재 처리중인 
		 다른 트랜잭션이 사용해야할 경우 
   		 지나친 commit은 지양해야한다.
 * 에러가 발생을 예방하는 방법?
 
5. Nested Loop Join 
 * 개념

6. transaction
 * 고립화 수준 
   -- 총 4단계 정리 
 * 고립화 수준에 따른 문제점
   -- 고립화 수준별 문제점 정리

7.pseudo 컬럼?

8. 비트맵 인덱스 엔트리?

9. 데이터베이스 성능 고도화 정석 해법 
 (1) 문제해결 : 모니터링 자료수집 -> 분석 진단 -> 튜닝 -> 평가 
 (2) 데이터 베이스 성능 튜닝 3대 핵심요소 
   (2-1) 라이브러리 캐시 최적화
   (2-2) 데이터베이스 Call 최소화
   (2-3) I/O 효율화 및 버퍼캐시 최적화

10. 인덱스 ???
    ** Table Full Scan vs Index Scan 

11. 라이브러리 캐시 최적화 
    ** 라이브러리 캐시 최적화시 고려사항
      -- 바인드 변수 중요성, 바인드 변수 사용시 부작용
      -- 과도한 parse call이 발생해도, cursor를 session에 캐싱 혹은 애플리케이션에 캐싱 하여 parse call을 줄이기
      -- daynamic SQL vs Static SQL
      -- Library cache에 부하를 주지않는 선에서 dynamic SQL을 사용하는 방법

    ** 라이브러리 캐시 
      -- 파싱 과정을 거친 SQL 커서를 재사용할 수 있도록 캐싱해 두는 메모리 공간
      -- 데이터베이스 오브젝트(테이블, 인덱스)에 대한 정보를 관리    

    ** 라이브러리 캐시 최적화를 위해 개발자가 신경 써야할 것
      -- 커서를 공유할 수 있는 형태로 SQL 작성
         * 공유커서 : 라이브러리 캐시의 파싱을 거친 SQL 커서를 말함
         * 공유커서가 무효화 될 수 있는 경우 
           - 테이블 컬럼 추가/삭제, 인덱스 변경, 오브젝트 통계 수집하는 DDL 실행
      -- 세션 커서 캐싱 기능 이용해 라이브러리 캐시에서 SQL을 찾는 비용을 줄이기
      -- 애플리케이션 커서 캐싱을 이용해 parse call을 줄이기 

    ** 라이브러리 캐시 부하 원인 
      -- 하드 파싱/ 소프트 파싱이 자주 일어날 때
      -- SQL 수행 도중 DDL문을 날릴 때(library cache lock과 library cache pin 대기 이벤트 발생)
         * library cache lock : 라이브러리 캐시 객체(LCO)구조를 보호, library cache pin : LCO의 정보를 읽거나 수정 
      -- Child Cursor를 공유하지 못할 때 
         * 실행환경(옵티마이저 param, 스키마..등)이 변경되었을 때 
      -- Parent Cursor를 공유하지 못할 때
         * 대/소문자 다름, 테이블에 스키마 붙음, 띄어쓰기, 주석처리, 옵티마이저 힌트 사용, 조건절 비교값(하드코딩)

     ** 바인드 변수의 중요성 
      -- 바인드 변수를 잘 활용하면 하드 파싱의 비율이 줄어들어 시스템 부하가 많이 줄어든다. 
      -- 바인드 변수를 사용하면 최초 수행할 때 최적화를 거친 실행계획을 캐시에 적재하고, 실행시점에는 그것을 
          그대로 가져와 값을 다르게 바인딩하면서 반복 재사용함

     ** 바인드 변수의 부작용과 해법 
      -- 바인딩 시점이 (최적화 시점보다 나중인)실행지점이기 때문에, 
          SQL 최적화 하는 시점에 조건절 컬럼의 데이터 분포도를 활용하지 못하는 문제를 가짐 
      -- 데이터 분포도를 활용하지 못함으로 평균 분포를 통해 실행계획을 세우는데, 평균 분포에 근거한 실행계획이
          최악일 수 있음(정확한 수치를 통한 계획이 아니기 때문에 그럼)
      -- 부작용의 해법 (한번 다시 봐야 할듯.. ㅠㅜ)
        * 바인드 변수 peeking 
          - 문제의 소지가 있어 잘 안씀 ㅋㅋ 개념이 어렵네요 ㅋㅋㅋ 
        * 적응적 커서 공유 
          - 이해가 잘 안가는데;; 
        * 입력값에 따라 SQL 분리
          - union all, IF 로 계획도가 비슷한 쿼리끼리 묶어 만들기
          - 하지만 union all은 OLTP 시스템에서 parse 과정에서의 부하가 있을 수 있음 그래서 상황에 따라 쓸 것
        * 예외적으로 Literal 상수값 사용 
          - 예외적으로 조건 값이 얼마 되지 않을 경우 상수값을 넣는 것도 부하를 줄일 수 있음
          - 하지만 대부분의 상황에서는 바인드 변수를 사용하는 것이 좋음!

      ** 세션 커서 캐싱 .. 다시 봐야할듯 ㅋㅋㅋ
      ** 어플리케이션 커서 캐싱 
       -- 세션커서를 이용해 Library Cache에 있는 공유 커서를 빠르게 찾아 오픈 할 수 있지만 이것보다 더 빠르게 
           커서를 사용할 수 있는 방법이 있는데 이를 애플리케이션 커서 캐싱 이라고 한다. 
       -- 어플리케이션 커서 캐싱의 효과는 Dynamic SQL, Cursor Variable을 사용할 때는 사라진다. 
          (Static SQL의 경우 커서 캐시를 유지하고 있다.)
       -- PL/SQL 내에서는 session_cached_cursors 파라미터의 갯수로 세션 커서 기능을 유지한다.
       -- n-Tier 환경에서는 DB Connection을 사용하고나서 곧바로 Connection을 반환하므로 
          애플리케이션 커서 캐싱기법을 사용하기 쉽지 않다. 
          하지만 PL/SQL를 잘 활용하면 라이브러리 캐시의 효율을 높일 수 있다. 

      ** Static vs Dynamic SQL 
       -- Static SQL(Embedded SQL) : 쿼리문을 String형 변수에 담지 않고 코드 사이에 직접 기술한 SQL문을 말한다. 
       -- Dynamic SQL : 쿼리문을 String형 변수에 담아서 기술하는 SQL문을 의미한다. 
       -- 효율을 고려한 코딩 방식 
         * 원칙상 Static SQL을 사용한다.
         * Dynamic SQL 사용시 
          - Static SQL을 preCompile하지 못하는 스칼라 서브쿼리, 분석함수, ANSI를 구문에서 사용할 경우 
          - 상황 조건에 따라 생성될 수 있는 SQL 최대 개수가 많아서 Static SQL로 일일이 나눠서 작성해야 할 경우
          - 최대한 bind변수를 사용한다. 
            (하지만 하드파싱에 의한 Library Cache의 부하가 적을 때는 예외적으로 bind 변수를 사용하지 않아도 된다.)
         * 선택적 검색 조건에 사용할 수 있는 기법 성능 비교
          - OR 조건 사용  
             ※ Table Full Scan을 처리함으로 인덱스 활용이 필요할 때는 이 방식을 사용해서는 안됨
          - Like 연산자를 사용하는 경우
	※ 조건값이 입력되지 않았을 경우 Table Full Scan이 유리할 수 있지만, 
                인덱스를 사용해 성능이 나빠질 수도 있다. 또한 컬럼이 not null인 경우에만 사용하는 것이 좋다
          - NVL 함수를 사용하는 경우 
          - DECODE 함수를 사용하는 경우 
	※ 조건값의 여부에 따라 Table Full Scan, Index Scan을 한다. 단, 컬럼의 경우 not null이어야 한다. 
          - UNION ALL을 사용하는 경우
	※ null값을 허용하고, 액세스 조건으로 의미있는 컬럼일 경우 사용

12. 데이터 베이스 Call 최소화
  ** Call 통계(Cursor 활동 상태에 따라 분류)
    -- Parse Call    : 실행계획을 탐색하거나 실행계획을 생성하는 것에 관한 정보를 포함 
    -- Execute Call : 커서를 실행하는 단계에 대한 통계를 보여줌
    -- Fetch Call    : select문에서 실제 레코드를 읽어 사용자가 요구한 결과집합을 반환하는 과정에 대한 통계
 
  ** User Call vs Recursive Call (Call이 어디서 발생했는지에 따라 분류)
    -- User Call       : 오라클 외부로부터 들어오는 Call 
      * User Call 최소화 방법 
        - Loop 쿼리를 해소하고 집학적 사고를 통해 One-SQL로 구현 
        - Array Processing : Array 단위 Fetch, Bulk Insert/Update/Delete
        - 부분범위처리 원리 활용 
        - 효과적인 화면 페이지 처리 
        - 사용자 정의 함수/프로시저/트리거의 적절한 활용
    -- Recursive Call : 오라클 내부에서 발생하는 Call 

13. I/O 효율화 및 버퍼캐시 최적화
  ** 블록 단위 I/O - I/O 효율화를 위한 개념
    -- 모든 DBMS에서 I/O는 블록단위로 이루어짐
    -- 블록 단위 I/O를 한다는 것은 하나의 레코드에서 하나의 컬럼만을 읽으려 할때도 
       레코드가 속한 블록 전체를 읽는다는 의미가 됨
    -- SQL 성능을 좌우하는 가장 중요한 성능지표는 액세스 하는 블록 개수이며, 
       옵티마이저의 판단에 가장 큰 영향을 미치는 것도 액세스해야할 블록의 개수임
    -- 다른 크기의 블록을 동시에 사용하는 방법
       * 각각 별도의 테이블 스페이스와 버퍼 pool을 구성함
    -- 블록 단위 I/O는 버퍼캐시와 데이터 파일 I/O에 모두 적용됨
       * 메모리 버퍼 캐시에서 블록을 읽고 쓸 때
       * 데이터 파일에 저장된 데이터 블록을 직접 읽거나 쓸 때
       * 데이터 파일에서 DB 버퍼 캐시로 블록을 적재할 때 
         - Single Block Read 또는 Multiblock Read 방식 사용
       * 버퍼 캐시에서 변경된 블록을 다시 데이터 파일에 저장할 때
         - Dirty 버퍼를 주기적으로 데이터 파일에 기록하는 것을 말하며, DBWR 프로세스에 의해 수행됨,
           성능 향상을 위해 한번에 여러 블록을 처리함
    -- Sequential Access 
       * 레코드간 논리적 또는 물리적 순서에 따라 차례대로 읽어 나가는 방식 
       * 인덱스 리프 블록에 위치한 모든 레코드는 포인터를 따라 *논리적으로 연결됨 
         - 논리적 : 인덱스 키값의 순서에 따라 포인터로 서로 연결되는 구조 
         - 물리적 : 포인터를 이용한 연결 구조 자체
       * Sequential Access 기능을 향상시키기 위해 Oracle이 내부적으로 사용하는 기능 
         - 인덱스 preFetch, MultiBlock I/O
    -- Random Access   
       * 레코드간 논리적/물리적 순서를 따르지 않고, 한건을 읽기위해 한블록씩 접근하는 방식
       * Random Access 기능을 향상시키기 위해 Oracle이 내부적으로 사용하는 기능 
        - 버퍼 Pinning, 테이블 preFetch
    -- I/O 튜닝의 핵심 원리 2가지 
       * Sequential 액세스의 선택도를 높임
        - 선택도 : 총 읽은 레코드에서 결과 집합으로 선택되는 비중  
       * Random 액세스의 발생량을 줄임 
        - DBMS는 하나의 컬럼을 읽더라도 하나의 레코드에 접근을 함으로 최대한 Random Access는 하지 않는게 좋음
  ** MEMORY vs DISK I/O - I/O 효율화를 위한 개념
    -- DISK I/O는 많이 비용이 발생함으로 MEMORY I/O를 사용하는 것이 좋음 
       하지만 MEMORY는 유한한 자원임으로 이를 효율적으로 사용할 필요가 있고, 이를 효율적으로 사용할 수 있도록
       버퍼 캐시 효율을 높이는 것을 통해 데이터베이스 효율을 높일 수 있음
      * 버퍼 캐시 효율을 측정하는 방법
       - 버퍼 캐시 히트율(Buffer Cache Hit Ratio)를 통한 측정
       - BCHR = (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) * 100 
	     = ((논리적 블록읽기 - 물리적 블록읽기) / 논리적 블록 읽기) * 100
	     = (1 - (물리적 블록 읽기) / (논리적 블록읽기)) * 100
         ※ 논리적 블록읽기 = 총 읽은 블록 수
         ※ 캐시에서 곧바로 찾은 블록 수 = 논리적 블록 읽기 - 물리적 블록 읽기
       * 모든 블록 읽기는 버퍼캐시를 통해 이루어지며, 캐시에서 찾아보고 없을 때 디스크로부터 블록을 찾고 
         블록을 찾은 이후 버퍼캐시에 적재한 후 읽는다. 
     -- 논리적 읽기 횟수가 너무 많을 경우, 경합이 발생 할 수 있음으로 논리적 읽기 횟수를 줄이는 노력이 필요함

  ** Single Block vs Multi Block I/O - I/O 효율화를 위한 개념
    -- Single Block I/O 
      * I/O call에 하나의 데이터 블록만 읽어 메모리에 적재하는 것을 말함 
        인덱스를 통해 테이블을 액세스 할때는 기본적으로 인덱스와 테이블 블록 모두 이 방식을 사용함
      * 읽은 블록을 MRU(Most Recently Used)쪽으로 연결함
    -- Multi Block I/O
      * I/O call이 필요한 시점에 인접한 블록들을 같이 읽어 메모리에 적재하는 것을 말함 
      * 읽은 블록을 LRU(Least Recently Used)쪽으로 연결함

   ** Prefetch - I/O 효율화를 위한 개념
    -- Prefetch는 한번에 여러개 Single Block I/O를 동시에 수행하는 것을 말함
    -- 서로 다른 익스텐드에 위치한 블록을 배치(Batch) 방식으로 미리 적재해두는 것
      * I/O call을 병렬 방식으로 동시에 여러개 수행한다. 
    -- Index Prefetch vs table Prefetch 
      * Index Prefetch
        - 인덱스 리프 블록을 읽을 때 DISK I/O가 필요한 블록이 있을 경우 하나만 들고 오는 것이 아니라 
          처리해야할 리프 블록을 같이 들고 오도록 설정 할 수 있음 
      * table Prefetch
        - Index Prefetch와 비슷함 

  ** RAC 캐시 퓨전 - I/O 효율화를 위한 개념
    -- 개념 이해가 필요할듯.... ㅠ
    -- 결론적으로 성능 향상을 위해서는 I/O call을 최소화 해야한다.

  ** Result 캐시 - I/O 효율화를 위한 개념
    -- 버퍼캐시에 위치하지 않고, Shared Pool에 위치해 시스템 I/O발생량을 최소화 해줌
    -- Result 캐시의 효율
      * DML이 거의 발생하지 않는 테이블을 참조
      * 반복 수행 요청이 많은 쿼리
      * 바인드 변수를 사용하는 쿼리는 Result 캐시의 사용을 지양하는게 좋음 

  ** I/O 효율화 원리 
    -- 필요한 최소 블록만 읽도록 쿼리를 작성한다.
    -- 최적의 옵티마이징 팩터를 제공
    -- 필요하다면 옵티마이저 힌트를 사용해 최적의 액세스 경로 유도 